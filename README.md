# LeetCode


### 一、数据结构和算法
掌握数据结构和算法直接的好处就是能写出性能更优的代码。算法是一种解决问题的思路和方法，从长期来看，大脑思考能力是个人最重要的核心竞争力，而算法是为数不多的能够训练大脑思考能力的途径之一。

关于要不要学数据结构和算法以及算法有没有用这种问题不想再多做解释，只能说志同道合者共行，如果你也感兴趣，可以和我一起学习数据结构和算法题。

> 学习路线看书学习数据结构基础知识，通过LeetCode算法题加深对数据结构的理解。

### 二、练习题目
该项目LeetCode主要包括：LeetCode推荐答案+详细备注+算法题思路说明文档。相关题目及答案如下链接：
#### 链表
[206-reverse-linked-list-反转链表](https://github.com/gaoshengnan/LeetCode/tree/master/src/main/java/linkedlist/reverseList)  
[141-linked-list-cycle-环形链表（判断是否有环）](https://github.com/gaoshengnan/LeetCode/tree/master/src/main/java/linkedlist/linkedListCycle)  
[142-linked-list-cycle-ii-环形链表II（如果有环，返回入环结点）](https://github.com/gaoshengnan/LeetCode/tree/master/src/main/java/linkedlist/linkedListCycleII)  
[24-swap-nodes-in-pairs-两两交换链表中的结点](https://github.com/gaoshengnan/LeetCode/tree/master/src/main/java/linkedlist/swapNodesInPairs)  
[25-reverse-nodes-in-k-group-K个一组反转链表](https://github.com/gaoshengnan/LeetCode/tree/master/src/main/java/linkedlist/reverseNodesInkGroup)  
[使用栈实现一个队列](https://github.com/gaoshengnan/LeetCode/tree/master/src/main/java/stack/ImplementQueueUsingStacks)  
[20-valid-parentheses-有效括号](https://github.com/gaoshengnan/LeetCode/tree/master/src/main/java/stack/validParentheses)

> 持续更新中。。。

### 三、常见数据结构

#### 1、数组
数组是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。

#### 1.1 访问
数组适合查找操作，排好序的数组，用二分法查找，时间复杂度是O(logn)。数组支持随机访问，根据下标随机访问的时间复杂度是O(1)。

#### 1.2 插入
如果在数组末尾插入，不需要移动数据，时间复杂度是O(1)，如果在数组的开头插入元素，那么所有的数据都要一次往后移动一位，最坏时间复杂度是O(n)。

如果数组中的数据是有序的，那就必须移动其他数据来完成插入操作；但是如果是无序的，当将某个数据插入到数组第k个位置时，可以直接将第k位的数据直接放入到数组最后，把新的元素放在第k个位置。

#### 1.3 删除
和插入类似，删除末尾数据，最好时间复杂度是O(1)，删除开头数据，最坏时间复杂度是O(n)。

在一些特殊场景中，我们不追求数据的连续性，可以将已删除的数据标记下来，这样每次的删除操作不是真正的进行搬移数据，而只是记录数据已经被删除，当数组没有更多空间存储数据时，再触发一次真正的删除操作，这样大大减少了删除导致的数据搬移。类似JVM的标记清楚算法。

#### 1.4 ArrayList和原声的数组比较
1、ArrayList最大的优势是可以将很多数组操作的细节封装起来，比如数组插入或者删除时需要搬移数据的操作，另外还有一个优势就是支持动态扩容。

动态扩容是指数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间，如果我们申请了大小为10的数组，当11个数据需要存储到数组中时，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。

2、ArrayList无法存储基本类型，比如int，long，需要封装成Integer、Long类，而Autoboxing、Unboxing则有一定的性能消耗，所以如果特别关注性能的话，或者希望使用基本类型的时候就可以选择数组。

3、总的来说，业务开发，直接使用容器就可以了，省时省力，毕竟损耗一丢丢性能，完全不会影响到系统整体的性能，但是如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器。

#### 1.5 为什么编程中数组从0开始编号 ？
k：索引下标
a[k]_address：第k个数据的内存地址
base_address：数组内存的首地址
type_size：存储的数据大小（比如int占4个字节）

计算数组内存地址的位置公式是a[k]_address = base_address + k * type_size，如果从1开始编号的话，公式就变成a[k]_address=base_address + (k-1) * type_size，对于CPU来说，每次随机访问数组都多了一次减法指令，为了减少一次减法操作，所以数组就选择了从0开始编号索引下标。

#### 2、链表
链表不需要一块连续的内存空间，它通过指针将一组零散的内存块串联起来使用。其中每个内存块叫做链表的结点，记录下个结点地址的指针叫做后继指针。

#### 2.1 单链表
链表的插入和删除是非常快速的，因为不需要做数据搬移，但是链表想要随机访问第k个元素就没有数组那么高效了，因为链表的数据不是连续的，没办法将首地址和下标带入寻址公式直接计算出对应的内存地址，而是需要根据指针一个结点一个结点的一次遍历，直到找到相应的结点，需要O(n)的时间复杂度。

#### 2.2 循环链表
在单链表基础上，尾结点的指针指向链表的头结点

#### 2.3 双向链表
每个结点不止有一个后继指针next指向后面的结点，还有一个前驱指针prev指向前面的结点。

* 删除和访问操作
当删除结点中“值等于某个给定值”的结点，无论单链表还是双向链表，为了查找到匹配的结点，都需要从头指针一个一个一次遍历，然后将其删除。尽管删除操作时间复杂度是O(1)，但是遍历查找的时间复杂度是O(n)。

当删除给定指针指向的结点，我们已经找到了要删除的结点，需要找到他的前驱结点，单链表不支持获取前驱结点，所以，为了找到前驱结点，还是要从头开始获取前驱结点。但是对于双向链表来说，有前驱指针，所以只需要O(1)的时间复杂度就可以。

除此之外，对于一个有序链表，双向链表在按值查询时，可以记录上次查找的位置，每次查询的时候，根据查找的值判断大小，然后决定往前找还是往后找，平均只需要查找一半的数据。

* 空间换时间设计思想
在实际的开发中，尽管双向链表比较耗费内存，也比单链表应用更加广泛，比如java中的linkedHashMap，这里体现一种用空间换时间的思想，当我们内存空间充足的时候，如果我们更加追求代码的执行速度，就可以选用空间复杂度相对较高，但时间复杂度相对较低的算法或者数据结构。反过来也类似。

#### 2.4 数组和链表的缺点
* 数组的缺点是大小固定，且需要占用整块连续的内存空间，如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致out of memory，如果声明的过小，又容易产生动态扩容发现数据搬移。

* 链表的缺点是需要耗费额外的存储空间去存储指针，而且对链表的频繁插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，就有可能频繁的GC。

#### 2.5 如何实现一个LRU缓存淘汰算法？

链表使用的经典场景，LRU（least recently userd），最少最近使用策略。

我的思路是这样的，维护一个按时间排序的有序单链表，越靠近尾部的结点是最早被访问的，当有一个新的数据被访问时，分以下两种情况：
* 如果数据已经在链表中，先遍历找到这个数据对应的结点，将原来数据删除，然后把数据插入到链表的头部。
* 如果数据不在链表中，要判断链表是否已经满了，如果未满，将数据插入到链表头部，如果已满，将链表尾结点删除，再将新的数据插入链表头部。

<div align="center"><img src="../src/main/resources/img/readme/LRU.png" height="300" width="800" ></div>

时间复杂度分析的话，不管缓存满不满，我们都需要遍历一遍链表，所以是O(n)的时间复杂度。实际上可以引入散列表来记录每个数据的位置，将缓存访问的时间复杂度降低到O(1)，在后续散列表会详细说明。

