package highFrequencyLeetcode.leetcode_70;

/**
 *
 * <p>
 *
 *  假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
 *
 *  每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
 *
 *  注意：给定 n 是一个正整数。
 *
 *  示例 1：
 *
 *  输入： 2
 *  输出： 2
 *  解释： 有两种方法可以爬到楼顶。
 *  1.  1 阶 + 1 阶
 *  2.  2 阶
 *
 *  示例 2：
 *
 *  输入： 3
 *  输出： 3
 *  解释： 有三种方法可以爬到楼顶。
 *  1.  1 阶 + 1 阶 + 1 阶
 *  2.  1 阶 + 2 阶
 *  3.  2 阶 + 1 阶
 *
 * </p>
 *
 * @author Seina
 * @version 2019-04-09 22:15:25
 *
 */
public class ClimbingStairs {

    /**
     * 解法1 暴力法
     * 时间复杂度： O(2ⁿ) 树形递归总节点数
     * 空间复杂度： O(n) 树的深度
     * 
     * 这种暴力破解会超出时间限制，显然不是我们想要的，但是可以理解一下代码
     * 多实践递归代码：找到一级递归，再找到终止条件，并拒绝在中间过程进行人肉递归
     */
    public int climbingStairs(int n) {
        return climbing_stairs(0, n);
    }

    /**
     * 递归模拟爬楼梯在每层每次走一步或者两步的所有情况
     * 
     * @param i：当前台阶数
     * @param n：总的台阶数
     * @return 总共有多少种走法
     */
    public int climbing_stairs(int i, int n) {
        //表示当前台阶数大于总台阶数，很显然这种情况不符合，走不通，记为 0
        if (i > n) {
            return 0;
        }
        //表示当前台阶数正好等于总的台阶数，那么这种情况符合，记为 1
        if (i == n) {
            return 1;
        }
        //总的可能性主要取决于在 0 层的时候迈 1 步还是迈 1 步
        //举例一共有 2 个台阶
        //我先迈 2 步，（2，2），退出递归返回 1
        //或者我先迈 1 步，(1,2)，来到第 1 层台阶，再迈 1 步（2，2），退出循环返回 1；也可以再迈 2 步，（3，2），退出循环返回 0 
        //所以当台阶数为 2 时，有两种走法，（2，2）或 （1，2）-> (2,2)
        return climbing_stairs(i + 1, n) + climbing_stairs(i + 2, n);
    }

    
}
