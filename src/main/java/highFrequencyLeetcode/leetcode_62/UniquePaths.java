package highFrequencyLeetcode.leetcode_62;


/**
 * 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
 *
 * 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
 *
 * 问总共有多少条不同的路径？
 *
 *
 *
 * 例如，上图是一个7 x 3 的网格。有多少可能的路径？
 *
 * 说明：m 和 n 的值均不超过 100。
 *
 * 示例 1:
 *
 * 输入: m = 3, n = 2
 * 输出: 3
 * 解释:
 * 从左上角开始，总共有 3 条路径可以到达右下角。
 * 1. 向右 -> 向右 -> 向下
 * 2. 向右 -> 向下 -> 向右
 * 3. 向下 -> 向右 -> 向右
 * 示例 2:
 *
 * 输入: m = 7, n = 3
 * 输出: 28
 *
 * @author Seina
 * @version 2019-07-23 07:00:09

 */
public class UniquePaths {

    /**
     * 解法1 动态规划
     *
     * 当前的路线总数 = 之前算好的到达左方向格子的路线总数 + 之前算好的到达上方向格子的路线总数，因为机器人每次只能向下或者向右移动，所以到达当前格子只能从左边或者右边过来
     *
     * 举例题中 m = 7，n = 3，S 表示起点，E 表示终点
     *
     *    |0 |1 |2 |3 |4 |5 |6 | m
     * |0 |S |1 |1 |1 |1 |1 |1 |
     * |1 |1 |2 |3 |4 |5 |6 |7 |
     * |2 |1 |3 |6 |10|15|21|E |
     *  n
     *
     * @param m：横着 m 个=列网格
     * @param n：竖着 n 行网格
     * @return 多少种不同路线
     */
    public int uniquePaths (int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) dp[i][0] = 1; // n = 0 那一行的表格，只能从左边向右过来，不能从上边向下过来，因为上边没有格子
        for (int i = 0; i < n; i++) dp[0][i] = 1; // m = 0 那一列的表格，只能从上边向下过来，不能从左边向右过来，因为左边没有格子
        for (int i = 1; i < m; i++)
            for (int j = 1; j < m; j ++)
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        return dp[m - 1][n - 1];//最后一个格子的路线总数
     }
}
